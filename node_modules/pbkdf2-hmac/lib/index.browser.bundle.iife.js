var pbkdf2Hmac=function(){"use strict";const e={"SHA-1":{outputLength:20,blockSize:64},"SHA-256":{outputLength:32,blockSize:64},"SHA-384":{outputLength:48,blockSize:128},"SHA-512":{outputLength:64,blockSize:128}};function t(...e){const t=e.reduce((e,t)=>e+t.length,0);if(!e.length)throw new RangeError("Cannot concat no arrays");const r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}function r(e,t){for(let r=0;r<e.length;r++)e[r]^=t[r]}return function(n,a,o,i,s="SHA-256"){return new Promise((c,u)=>{s in e||u(new RangeError("Valid hash algorithm values are any of "+Object.keys(e))),"string"==typeof n?n=(new TextEncoder).encode(n):n instanceof ArrayBuffer?n=new Uint8Array(n):ArrayBuffer.isView(n)||u(RangeError("P should be string, ArrayBuffer, TypedArray, DataView")),"string"==typeof a?a=(new TextEncoder).encode(a):a instanceof ArrayBuffer?a=new Uint8Array(a):ArrayBuffer.isView(a)||u(RangeError("S should be string, ArrayBuffer, TypedArray, DataView")),crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveBits"]).then(f=>{const y={name:"PBKDF2",hash:s,salt:a,iterations:o};crypto.subtle.deriveBits(y,f,8*i).then(e=>c(e),f=>{(async function(n,a,o,i,s){if(!(s in e))throw new RangeError("Valid hash algorithm values are any of "+Object.keys(e));if(!Number.isInteger(o)||o<=0)throw new RangeError("c must be a positive integer");const c=e[s].outputLength;if(!Number.isInteger(i)||i<=0||i>=(2**32-1)*c)throw new RangeError("dkLen must be a positive integer < (2 ** 32 - 1) * hLen");const u=Math.ceil(i/c),f=i-(u-1)*c,y=new Array(u);0===n.length&&(n=new Uint8Array(e[s].blockSize));n=await crypto.subtle.importKey("raw",n,{name:"HMAC",hash:{name:s}},!0,["sign"]);const w=async function(e,t){const r=await crypto.subtle.sign("HMAC",e,t);return new Uint8Array(r)};for(let e=0;e<u;e++)y[e]=await h(n,a,o,e+1);async function h(e,n,a,o){const i=await w(e,t(n,function(e){const t=new ArrayBuffer(4);return new DataView(t).setUint32(0,e,!1),new Uint8Array(t)}(o)));let s=i;for(let t=1;t<a;t++)s=await w(e,s),r(i,s);return i}return y[u-1]=y[u-1].slice(0,f),t(...y).buffer})(n,a,o,i,s).then(e=>c(e),e=>u(e))})},e=>u(e))})}}();
